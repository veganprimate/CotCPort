### **LANGUAGE:**  [English](QuestEvent_Prog_en.md) | [日本語](QuestEvent_Prog_jp.md) | [中文](QuestEvent_Prog_zh.md) | [한국어](QuestEvent_Prog_kr.md)
<img width="1920" height="1080" alt="pic-window-260119-1350-16" src="https://github.com/user-attachments/assets/9370d2ef-1087-4475-b040-7f1f2ac82368" />

この雑然とした画像からも分かる通り、『オクトパストラベラー 大陸の覇者』（以下「大陸覇者」）からクエストを移植すること自体は確実に可能です。問題はイベントの移植にあります。イベントは、カットシーン、ボス戦の開始、戦闘中の会話、ダンジョン内のスイッチなど、さらに多岐にわたる要素を担っています。イベントがなければ、クエストはクエストマーカーと報酬があるだけの「入れ物」に過ぎません。

`/Game/Content/Local/DataBase/Event/` 配下の EventList アセットを見ると、ゲームがイベントIDを読み込む際に、`m_Name` と `m_Version` がパス `/Game/Content/Local/DataBase/Event/V[m_Version]/[m_Name].[m_Name]` に解決されるのではないか、と考えてしまいがちです。しかし残念ながら、そうではありません。テストの結果、ゲームはこれらのエントリを参照しておらず、イベントIDをイベントアセットへと至るパスに内部的に紐付けているように見えます。

さらに、同じイベントであっても、どのイベントアセットに対して新しい package プロパティをパッチするか、そして特に「どのフォルダに置かれているか」によって、ゲーム内での再生内容が変わります。
たとえば VPartychat 配下のイベントは自動的に Wishvale の酒場が背景になり、VTest はそこで再生できるイベントの種類が非常に制限されます。つまり EventList の `m_Kind` キーは事実上無視されている、ということになります。

このことから、EventList に新規エントリを追加するだけではゲームにカスタムイベントを追加できないと考えられます。エンジンが（あるいはこれから）完全な Unreal のオブジェクトパスを使用する、その地点でパイプラインをフック（介入）する必要があります。

私は現在、UE4SS 用の dll モッドを開発しており、PolyHook2 を用いてまさにそれを実現しようとしています。テンプレートとしては、[このモッド](https://github.com/UE4SS-RE/RE-UE4SS/tree/main/cppmods/KismetDebuggerMod) を使用しています。
また、Dumper-7 で生成した OT0 の IDA マッピング（#resources にある SDK を参照。BravelyPath Modular Discord 内にあります）を用い、IDA による解析も継続的に行っています。現時点で成功しているのは、実行時（runtime）にイベントIDを上書きするところまでです。

**これまでに判明していること（実装済み/確認済みの内容）：**
- インタプリタ／ハンドラのチェーンを確認：イベントコマンドのディスパッチャ（`sub_144634800`）は、コマンド 1000（イベント内でイベントをロードする役割を持つ `EvCmPlayEvent`）を `sub_144623F60`（PlayEvent のネイティブハンドラ）へルーティングします。
- しかし残念ながら、リゾルバは「パスリゾルバ」ではありません：`sub_144623F60` の内部では、EventID（int）を文字列に変換するために `sub_140EFEC60` を呼び出しますが、その出力は *固定長の短い文字列*（例：`L"9919"`）であり、`/Game/Content/Local/DataBase/Event/...` のようなパスは保持できません。
- 短いキーが後段のシステムで使われること、そしてその格納先を特定：詳細なロギングにより、`sub_144623F60` がキー文字列をイベントマネージャのスロット構造体に格納していることが分かりました。
  - `SlotPtr = BasePtr + SlotIndex * 0x23A0`
  - キーフィールドの位置：`SlotPtr + 0x250`
  したがって後段システム側はリゾルバを再実行しておらず、スロットに保存されたキーをそのまま消費しています。

保存されるのが短いキーのみである（おそらく、イベントIDを読み込む経路が複数存在するため――例：クエスト経由、NPC 経由、戦闘中、イベント内からの呼び出し等――またはイベントシステムを late-bind 可能にしたり、キャッシュ／レプリケーション／キューイングしたり、後で別サブシステムで処理したりする必要があるため）以上、ゲームは後段でおそらく次のような処理を行っているはずです：
1. `SlotPtr + 0x250` からキー `L"9919"` を読み出す
2. そのキーに基づいてフルのアセットパスを組み立てる、またはルックアップを行う
3. オブジェクト（イベントアセット、パッケージ、クラスインスタンス等）をロード／解決する

この「後段」の関数こそが探し当てるべき対象です。その関数をフックできれば、フルパス（もしくはオブジェクト参照）を安全に差し替えることができ、真にカスタムアセットをサポートできるようになります。

下の画像が示す通り、大陸覇者から直接移植したイベントは概ね問題なく再生できるはずなので、ここでの主問題は「カスタムのイベントアセットをサポートすること」にあります。
<img width="869" height="479" alt="image" src="https://github.com/user-attachments/assets/a7cbaf77-d0c2-44f2-81ec-d9a54d865f87" />



将来的に重要になり得る別の問題として、OT0 の既存マップに新しい PathActor データを追加する方法があります。たとえば、新しい NPC やオブジェクトを追加する、といったケースです。大陸覇者由来のカスタムクエストは、独自の NPC 一式と、新規 PathActor を参照する会話リストを持つことが多いためです。実装自体は非常に単純かもしれませんが、まだ試していません。

Local/DataBase/Quest および Local/DataBase/Event 配下のファイル構造、ならびに新しいイベント／クエストの追加方法については、[カスタムクエストとイベントを追加する方法](customqsts_jp.md) を参照してください。
