## **LANGUAGE:**  [English](Custom_Prog_en.md) | [日本語](Custom_Prog_jp.md) | [中文](Custom_Prog_zh.md) | [한국어](Custom_Prog_kr.md)

원칙적으로는(아주 제한적인 형태로) 가능하지만, CotC 코드를 『옥토패스 트래블러 0』에 “그대로 포팅”하는 것이라기보다는 OT0의 UE5 런타임을 훅/확장해서 OT0 안에 CotC와 유사한 시스템을 재구현하는 쪽에 가깝습니다.
실현 가능성은 결국 OT0에 “근처에” 얹어 쓸 수 있는 서브시스템(예: 미니게임 프레임워크, UI 라우팅 등)이 있느냐, 아니면 기능 스택 전체를 새로 만들어야 하느냐에 달려 있습니다.

UE5 기반의 출시(Shipping) 게임에서 C++ 모드로 보통 할 수 있는 일은 다음과 같습니다:
- 네이티브 함수를 가로채기(detours/vtable hooks)하고 동작을 변경
- 리플렉션된 `UFunction` 호출 / 런타임에서 `UObject` 생성(다만 OT0는 네이티브 처리 비중이 큼)
- UI(UMG 위젯) 및 입력 처리 주입
- 경로를 마운트/리다이렉트할 수 있다면 신규 에셋 로드
- 게임이 데이터 기반(DataTables, DataAssets)이라면 신규 “콘텐츠” 데이터를 추가하거나, 하드코딩이라면 에뮬레이션으로 우회

‘포춘 보드 게임(Fortune Board Game)’ 같은 콘텐츠가 OT0로 이식되기까지는 아마도 꽤 오랜 시간이 걸릴 것입니다.
또한 상태 이상(ailments) 포팅도, 기존의 사용되지 않는 값이 있다면(있다는 전제) 그것을 재활용하지 않는 한 불가능할 수 있습니다. 상태 이상은 하드코딩된 enum/switch 로직으로 구현된 것으로 보이기 때문입니다(`SkillAilmentType` DataBase 파일은 상태 이상의 “외형(연출)”만 다루는 것으로 보이며, 이 목록에 상태 이상을 추가해도 기능적으로 동작하지 않습니다. OT0의 상태 이상을 라벨까지 완전히 동일하게 복사한 경우에도 마찬가지입니다).
