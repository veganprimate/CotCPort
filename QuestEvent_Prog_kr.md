### **LANGUAGE:**  [English](QuestEvent_Prog_en.md) | [日本語](QuestEvent_Prog_jp.md) | [中文](QuestEvent_Prog_zh.md) | [한국어](QuestEvent_Prog_kr.md)
<img width="1920" height="1080" alt="pic-window-260119-1350-16" src="https://github.com/user-attachments/assets/9370d2ef-1087-4475-b040-7f1f2ac82368" />

이 다소 어수선한 스크린샷에서 보이듯, 『옥토패스 트래블러: 대륙의 패자』(이하 “대륙의 패자”)의 **퀘스트**를 이식하는 것 자체는 분명 가능합니다. 문제는 **이벤트**의 이식에 있습니다. 이벤트는 컷신, 보스전 개시 트리거, 전투 중 대사, 던전 내 스위치 등 훨씬 더 많은 요소를 담당합니다. 이벤트가 없다면 퀘스트는 퀘스트 마커와 보상만 남는 셈입니다.

`/Game/Content/Local/DataBase/Event/` 아래의 EventList 에셋을 보면, 게임이 이벤트 ID를 로드했을 때 `m_Name` 및 `m_Version` 키가 `/Game/Content/Local/DataBase/Event/V[m_Version]/[m_Name].[m_Name]` 경로로 해석될 것이라고 생각하기 쉽습니다. 하지만 유감스럽게도 그렇지 않습니다. 테스트 결과 게임은 이러한 항목을 신경 쓰지 않으며, 이벤트 ID를 이벤트 에셋으로 이어지는 경로에 내부적으로 매핑해 두고 있는 것으로 보입니다.

게다가 같은 이벤트라도, 어떤 이벤트 에셋에 새로운 package 프로퍼티를 패치하느냐—그리고 특히 그것이 어떤 폴더에 위치하느냐—에 따라 게임 내에서 재생되는 방식이 달라집니다.
예를 들어 VPartychat 아래의 이벤트는 자동으로 Wishvale 선술집을 배경으로 사용하고, VTest는 그 안에서 재생될 수 있는 이벤트의 종류가 매우 제한적입니다. 이는 EventList의 `m_Kind` 키를 사실상 무시하는 동작입니다.

이런 정황은 EventList에 새 엔트리를 추가하는 것만으로는 게임에 커스텀 이벤트를 추가할 수 없음을 시사합니다. 엔진이 (이미 사용했거나 곧 사용하려는) 완전한 Unreal 오브젝트 경로를 갖는 지점에서 파이프라인을 가로채야 합니다.

저는 현재 UE4SS용 dll 모드를 개발 중이며, PolyHook2를 사용해 정확히 이를 수행하고 있습니다. 템플릿으로는 아래 모드를 사용하고 있습니다:
https://github.com/UE4SS-RE/RE-UE4SS/tree/main/cppmods/KismetDebuggerMod
또한 Dumper-7로 생성한 OT0용 IDA 매핑을 통해(BravelyPath Modular Discord의 #resources에 있는 SDK 참고) IDA를 광범위하게 사용하고 있습니다. 현재까지는 런타임에서 Event ID를 오버라이드하는 데까지만 성공했습니다.

**완료된 내용:**
- 인터프리터/핸들러 체인을 확인했습니다: 이벤트 커맨드 디스패처(`sub_144634800`)는 커맨드 1000(이벤트 안에서 이벤트를 로드하는 역할을 하는 `EvCmPlayEvent`)을 `sub_144623F60`(PlayEvent 네이티브 핸들러)로 라우팅합니다.
- 하지만 유감스럽게도 resolver는 “경로(path) resolver”가 아닙니다: `sub_144623F60` 내부에서 EventID(int)를 문자열로 변환하기 위해 `sub_140EFEC60`을 호출하는데, 그 출력은 *고정 길이의 짧은 문자열* (예: `L"9919"`)이며 `/Game/Content/Local/DataBase/Event/...` 같은 경로를 담을 수 없습니다.
- 짧은 키가 이후 시스템에서 사용되기 위해 어디에 저장되는지 확인했습니다: 공격적인 로깅을 통해, `sub_144623F60`이 키 문자열을 이벤트 매니저의 슬롯(slot) 구조체에 저장한다는 것을 확인했습니다:
  - `SlotPtr = BasePtr + SlotIndex * 0x23A0`
  - 키 필드 위치: `SlotPtr + 0x250`
  따라서 하위(다운스트림) 시스템은 resolver를 다시 실행하지 않고, 슬롯에 저장된 키를 그대로 소비합니다.

짧은 키만 저장된다는 점(아마도 게임에 Event ID를 로드하는 경로가 여러 가지이기 때문—퀘스트를 통해서인지, NPC를 통해서인지, 전투 중인지, 이벤트 내부 호출인지 등—그리고/또는 이벤트 시스템을 지연 바인딩(late-bind)하거나 캐시/복제/큐잉하거나, 나중에 다른 서브시스템에서 처리할 수 있도록 하기 위함)으로 미루어 볼 때, 게임은 이후 어딘가에서 다음과 같은 처리를 해야 합니다:
1. `SlotPtr + 0x250`에서 키 `L"9919"`를 읽음
2. 그 키를 기반으로 전체 에셋 경로를 만들거나, 해당 키로 룩업(조회)을 수행
3. 오브젝트(이벤트 에셋, 패키지, 클래스 인스턴스 등)를 로드/해결(resolve)
우리가 찾아야 하는 것은 바로 이 “이후” 단계의 함수입니다. 그 함수를 훅(hook)하면 전체 경로(또는 오브젝트 레퍼런스)를 안전하게 교체할 수 있고, 진정한 의미에서 커스텀 에셋을 지원할 수 있습니다.

아래 이미지에서 보이듯, 대륙의 패자에서 직접 이식한 이벤트는 대부분 정상적으로 재생될 것으로 보입니다. 따라서 여기서의 핵심 문제는 커스텀 이벤트 에셋을 지원하는 것입니다.
<img width="869" height="479" alt="image" src="https://github.com/user-attachments/assets/a7cbaf77-d0c2-44f2-81ec-d9a54d865f87" />



추후 더 중요해질 수 있는 또 다른 이슈는, 기존 OT0 맵에 새로운 PathActor 데이터를 추가하는 방법입니다(예: 새로운 NPC나 오브젝트 추가). 대륙의 패자 기반 커스텀 퀘스트는 종종 자체 NPC 세트를 가지고 있으며, 새로운 PathActor를 참조하는 대화 목록(talk list)을 포함하기 때문입니다. 구현 자체는 아주 단순할 수도 있지만, 아직 시도해 보지는 않았습니다.

Local/DataBase/Quest 및 Local/DataBase/Event 아래 파일 구조와, 새로운 이벤트/퀘스트를 추가하는 방법에 대한 가이드는 [커스텀 퀘스트 및 이벤트 추가 방법](customqsts_kr.md)를 참고해 주세요.
